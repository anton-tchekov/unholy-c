let _tokenizer_current,
	_tokenizer_input_offset,
	_tokenizer_line_begin,
	_tokenizer_data_offset,
	_tokenizer_row,
	_tokenizer_col;

let _token_row,
	_token_col,
	_token_type,
	_token_number,
	_token_identifier;

/*
u8 NumGlobals, BreakNesting, ContinueNesting;
u16 UsagesCount, Offset;
AddressStack BreakStack, ContinueStack;
IdentifierMap Variables, Functions, Constants;
*/

let _keywords;

let TT_NULL,
	TT_NUMBER,
	TT_FN_IDENTIFIER,
	TT_LET_IDENTIFIER,
	TT_KEYWORD,
	TT_IF,
	TT_ELIF,
	TT_ELSE,
	TT_DO,
	TT_WHILE,
	TT_FOR,
	TT_TO,
	TT_INC,
	TT_DEC,
	TT_LET,
	TT_FN,
	TT_BREAK,
	TT_CONTINUE,
	TT_RETURN,
	TT_LOOP,
	TT_TRUE,
	TT_FALSE,
	TT_CONST,
	TT_SWITCH;

let OFFSET_RODATA;

let ERROR_UNEXPECTED_CHARACTER,
	ERROR_INV_ESCAPE_SEQUENCE,
	ERROR_EXPECTED_DIGIT;

fn _ascii_hex(c)
{
	let bias;
	bias = 0;
	if ge(c, 'A') { bias = 9; }
	return add(and(c, 15), bias);
}

fn _is_hex(c)
{
	if isdigit(c) { return 1; }
	if ge(c, 'A') { if le(c, 'F') { return 1; } }
	return 0;
}

fn _is_bin(c)
{
	if eq(c, '0') { return 1; }
	if eq(c, '1') { return 1; }
	return 0;
}

fn is_identifier_char(c)
{
	if isalnum(c) { return 1; }
	if eq(c, '_') { return 1; }
	return 0;
}

fn _tokenizer_read()
{
	_tokenizer_current = ru8(_tokenizer_input_offset);
	if eq(_tokenizer_current, '\n') {
		_tokenizer_row = add(_tokenizer_row, 1);
		_tokenizer_col = -1;
		_tokenizer_line_begin = add(_tokenizer_input_offset, 1);
	}
}

fn _tokenizer_lookahead()
{
	return ru8(add(_tokenizer_input_offset, 1));
}

fn _tokenizer_advance()
{
	if eq(_tokenizer_current, '\0') {
		return '\0';
	}

	_tokenizer_input_offset = add(_tokenizer_input_offset, 1);
	_tokenizer_col = add(_tokenizer_col, 1);
	_tokenizer_read();
	return _tokenizer_current;
}

fn _tokenizer_current()
{
	return _tokenizer_current;
}

fn tokenizer_init()
{
	_tokenizer_data_offset = 0;
	_tokenizer_line_begin = 0;
	_tokenizer_input_offset  = 0;
	_tokenizer_col  = 0;
	_tokenizer_row = 1;
	_tokenizer_read();
}

fn _tokenizer_char()
{
	let b, c, ret;
	c = _tokenizer_current();
	if eq(c, '\\')
	{
		c = _tokenizer_advance();
		/*if   eq(c, '\'') { ret = '\''; }
		el*/if eq(c, '\\') { ret = '\\'; }
		elif eq(c, '\"') { ret = '\"'; }
		elif eq(c, '0')  { ret = '\0'; }
		elif eq(c, 'a')  { ret = '\a'; }
		elif eq(c, 'b')  { ret = '\b'; }
		elif eq(c, 'e')  { ret = 0x1B; }
		elif eq(c, 'f')  { ret = '\f'; }
		elif eq(c, 'n')  { ret = '\n'; }
		elif eq(c, 'r')  { ret = '\r'; }
		elif eq(c, 't')  { ret = '\t'; }
		elif eq(c, 'v')  { ret = '\v'; }
		elif eq(c, 'x') {
			b = _tokenizer_advance();
			if not(_is_hex(b)) {
				error(ERROR_UNEXPECTED_CHARACTER);
			}

			c = _tokenizer_advance();
			if not(_is_hex(c)) {
				error(ERROR_UNEXPECTED_CHARACTER);
			}

			ret = add(shl(_ascii_hex(b), 4), _ascii_hex(c));
		}
		else {
			error(ERROR_INV_ESCAPE_SEQUENCE);
		}
	}
	elif isprint(c)
	{
		ret = c;
	}
	else
	{
		error(ERROR_UNEXPECTED_CHARACTER);
	}

	return ret;
}

fn _tokenizer_comment()
{
	let c;

	_tokenizer_advance();
	c = _tokenizer_advance();
	while c
	{
		c = _tokenizer_advance();
		if ne(c, '*') {
			continue;
		}

		c = _tokenizer_advance();
		if eq(c, '/') {
			break;
		}
	}

	_tokenizer_advance();
}

fn _tokenizer_space()
{
	while isspace(_tokenizer_advance()) {}
}

fn _is_comment_start(c, d)
{
	if eq(c, '/') { if eq(d, '*') { return 1; } }
	return 0;
}

fn _tokenizer_skip()
{
	let c;
	loop {
		c = _tokenizer_current();
		if _is_comment_start(c, _tokenizer_lookahead()) {
			_tokenizer_comment();
		}
		elif isspace(c) {
			_tokenizer_space();
		}
		else {
			break;
		}
	}
}

fn _tokenizer_identifier()
{
	let keyword, c;

	_token_number = _tokenizer_input_offset;
	c = _tokenizer_current();
	while is_identifier_char(c)
	{
		c = _tokenizer_advance();
	}

	keyword = _keyword_find(_token_number);
	if ge(keyword, 0) {
		if eq(keyword, TT_TRUE) {
			_token_type = TT_NUMBER;
			_token_number = 1;
			return;
		}
		elif eq(keyword, TT_FALSE) {
			_token_type = TT_NUMBER;
			_token_number = 0;
			return;
		}
		else
		{
			_token_type = keyword;
			return;
		}
	}

	_tokenizer_skip();
	if eq(_tokenizer_current(), '(') {
		_token_type = TT_FN_IDENTIFIER;
	} else {
		_token_type = TT_LET_IDENTIFIER;
	}
}

fn _tokenizer_hexadecimal()
{
	let c, n;
	n = 0;
	c = _tokenizer_advance();
	while _is_hex(c) {
		n = add(shl(n, 4), _ascii_hex(c));
		c = _tokenizer_advance();
	}

	_token_number = n;
}

fn _tokenizer_binary()
{
	let c, n;
	n = 0;
	c = _tokenizer_advance();
	while _is_bin(c) {
		n = add(shl(n, 1), sub(c, '0'));
		c = _tokenizer_advance();
	}

	_token_number = n;
}

fn _tokenizer_float(n)
{
	let c, f, d;
	c = _tokenizer_advance();
	if not(isdigit(c))
	{
		error(ERROR_EXPECTED_DIGIT);
	}

	f = 0;
	if gt(d, 0) { d = 1; } else { d = -1; }
	while isdigit(c)
	{
		f = add(mul(f, 10), sub(c, '0'));
		d = mul(d, 10);
		c = _tokenizer_advance();
	}

	_token_number = add(itf(n), divf(itf(f), itf(d)));
	return 0;
}

fn _tokenizer_decimal(b)
{
	let n, c, is_neg;
	c = _tokenizer_current();
	if eq(b, '-')
	{
		is_neg = 1;
		n = 0;
		if not(isdigit(c))
		{
			error(ERROR_EXPECTED_DIGIT);
		}
	}
	else
	{
		is_neg = 0;
		n = sub(b, '0');
	}

	while isdigit(c)
	{
		n = add(mul(n, 10), sub(c, '0'));
		c = _tokenizer_advance();
	}

	if is_neg
	{
		n = sub(0, n);
	}

	if eq(c, '.')
	{
		return _tokenizer_float(n);
	}

	_token_number = n;
	return 0;
}

fn _tokenizer_number()
{
	let c, b;
	_token_type = TT_NUMBER;
	b = _tokenizer_current();
	c = _tokenizer_advance();
	if eq(c, 'x')
	{
		_tokenizer_hexadecimal();
	}
	elif eq(c, 'b')
	{
		_tokenizer_binary();
	}
	else
	{
		return _tokenizer_decimal(b);
	}

	return 0;
}

fn _tokenizer_char_literal()
{
	let v, c;
	_tokenizer_advance();
	v = _tokenizer_char();
	/*if eq(v, '\'')
	{
		error(ERROR_UNEXPECTED_CHARACTER);
	}*/

	c = _tokenizer_advance();
	/*if ne(c, '\'')
	{
		error(ERROR_UNTERMINATED_CHAR_LITERAL);
	}*/

	_tokenizer_advance();
	_token_type = TT_NUMBER;
	_token_number = v;
	return 0;
}

fn _emit_data(c)
{
	w8(add(OFFSET_RODATA, _tokenizer_data_offset), c);
	_tokenizer_data_offset = add(_tokenizer_data_offset, 1);
}

fn _tokenizer_string_literal()
{
	let v, offset;
	offset = _tokenizer_data_offset;
	do {
		while ne(_tokenizer_advance(), '\"')
		{
			_emit_data(_tokenizer_char());
		}

		_tokenizer_advance();
		_tokenizer_skip();
	}
	while eq(_tokenizer_current(), '\"');
	_emit_data('\0');
	_token_type = TT_NUMBER;
	_token_number = offset;
	return 0;
}

fn _is_number_start_char(c)
{
	if eq(c, '-') { return 1; }
	if isdigit(c) { return 1; }
	return 0;
}

fn _is_identifier_start_char(c)
{
	if eq(c, '_') { return 1; }
	if isalpha(c) { return 1; }
	return 0;
}

fn tokenizer_next()
{
	let c;
	_tokenizer_skip();
	c = _tokenizer_current();
	_token_row = _tokenizer_row;
	_token_col = _tokenizer_col;
	if eq(c, '\0')
	{
		_token_type = TT_NULL;
	}
	/*elif eq(c, '\'')
	{
		_tokenizer_char_literal();
	}*/
	elif eq(c, '\"')
	{
		_tokenizer_string_literal();
	}
	elif _is_identifier_start_char(c)
	{
		_tokenizer_identifier();
	}
	elif _is_number_start_char(c)
	{
		_tokenizer_number();
	}
	else
	{
		_token_type = c;
		_tokenizer_advance();
	}
}

fn _string_find(str, name)
{
	let found, id, c, d, s, p;

	id = 0;
	found = 1;
	s = str;
	p = name;
	c = r8(s);
	while ne(c, '|') {
		c = r8(s); s = add(s, 1);
		d = r8(p); p = add(p, 1);
		if eq(c, '\0') {
			if eq(found, 1) { if not(d) {
				return id;
			}}

			found = 1;
			id = add(id, 1);
			p = name;
		}
		elif not(d) {
			found = 0;
		}
		elif ne(d, c) {
			found = 0;
		}
	}

	return -1;
}

fn _keyword_find(name)
{
	let ret;
	ret = _string_find(_keywords, name);
	if lt(ret, 0) {
		return ret;
	}

	return add(TT_KEYWORD, ret);
}









/* --- ADDRESS STACK ---*/
/* for `break;` and `continue;` statements */
typedef struct ADDRESS_STACK
{
	u8 Top;
	u16 Offset;
} AddressStack;

fn address_stack_update(AddressStack *as, prev, addr)
{
	while(as->Top > prev)
	{
		--as->Top;
		memory_w16(BANK_INTERPRETER,
			OFFSET_CODE + memory_r16(BANK_PARSER, as->Offset + 2 * as->Top), addr);
	}
}

fn address_stack_push(AddressStack *as, addr)
{
	memory_w16(BANK_PARSER, as->Offset + 2 * as->Top, addr);
	++as->Top;
}

/* --- IDENTIFIER MAP --- */
/* for storing variable and function names */
typedef struct IDENTIFIER_MAP
{
	u16 Count, Offset;
} IdentifierMap;

fn identifier_map_find(IdentifierMap *map, *key)
{
	let i, offset, c, r, *p;
	for(i = 0; i < map->Count; ++i)
	{
		p = key;
		offset = memory_r16(BANK_PARSER, map->Offset + 2 * i);
		while((c = *p) && (r = memory_r8(BANK_INPUT, OFFSET_INPUT + offset)) == c)
		{
			++p;
			++offset;
		}

		r = memory_r8(BANK_INPUT, OFFSET_INPUT + offset);
		if(c == '\0' && !is_identifier_char(r))
		{
			return i;
		}
	}

	return -1;
}

fn _identifier_map_insert(IdentifierMap *map, offset)
{
	memory_w16(BANK_PARSER, map->Offset + 2 * map->Count, offset);
	return map->Count++;
}

fn identifier_map_insert(IdentifierMap *map, offset, key)
{
	if(identifier_map_find(map, key) >= 0)
	{
		error(ERROR_DUP_MAP_ELEM);
	}

	return _identifier_map_insert(map, offset);
}

/* --- FUNCTIONS --- */
fn _fn_params_get(idx)
{
	return memory_r8(BANK_PARSER, OFFSET_FUNCTION_PARAMS + idx);
}

fn _fn_params_set(idx, parameters)
{
	memory_w8(BANK_PARSER, OFFSET_FUNCTION_PARAMS + idx, parameters);
}

fn _fn_addr_get(idx)
{
	return memory_r16(BANK_PARSER, OFFSET_FUNCTION_ADDRS + 2 * idx);
}

fn _fn_addr_set(idx, addr)
{
	memory_w16(BANK_PARSER, OFFSET_FUNCTION_ADDRS + 2 * idx, addr);
}

fn _fn_usage_get(idx)
{
	return memory_r16(BANK_PARSER, OFFSET_FUNCTION_USAGES + 2 * idx);
}

fn _fn_usage_set(idx, addr)
{
	memory_w16(BANK_PARSER, OFFSET_FUNCTION_USAGES + 2 * idx, addr);
}

fn _fn_usage_add(void)
{
	_fn_usage_set(_parser.UsagesCount++, _parser.Offset);
}

/* --- EMIT --- */
fn _emit8(v)
{
	memory_w8(BANK_INTERPRETER, OFFSET_CODE + _parser.Offset, v);
	_parser.Offset += 1;
}

fn _emit16(v)
{
	memory_w16(BANK_INTERPRETER, OFFSET_CODE + _parser.Offset, v);
	_parser.Offset += 2;
}

fn _emit32(v)
{
	memory_w32(BANK_INTERPRETER, OFFSET_CODE + _parser.Offset, v);
	_parser.Offset += 4;
}

fn _skip(bytes)
{
	_parser.Offset += bytes;
}

fn _pushi(value)
{
	if(value <= 0xFF)
	{
		_emit8(INSTR_PUSHI8);
		_emit8(value);
	}
	else if(value <= 0xFFFF)
	{
		_emit8(INSTR_PUSHI16);
		_emit16(value);
	}
	else
	{
		_emit8(INSTR_PUSHI32);
		_emit32(value);
	}
}

/* --- PARSER --- */
fn parser_compile(void)
{
	_parser.Variables.Offset = OFFSET_VARIABLES;
	_parser.Functions.Offset = OFFSET_FUNCTIONS;

	_parser.BreakStack.Offset = OFFSET_BREAK_STACK;
	_parser.ContinueStack.Offset = OFFSET_CONTINUE_STACK;

	tokenizer_next();
	while(_token.Type == TT_LET)
	{
		_parser_var();
		tokenizer_next();
	}

	_parser.NumGlobals = _parser.Variables.Count;
	if(_parser.NumGlobals)
	{
		_emit8(INSTR_DSP);
		_emit8(_parser.NumGlobals);
	}

	_parser_call_main();

	while(_token.Type != TT_NULL)
	{
		EXPECT(TT_FN, ERROR_EXPECTED_FN);
		_parser_fn();
		tokenizer_next();
	}

	_parser_check_impl();
	return 0;
}

fn _parser_call_main()
{
	let i;
	i = _identifier_map_insert(&_parser.Functions, "main");
	_fn_addr_set(i, 0);
	_fn_params_set(i, 0);

	_emit8(INSTR_CALL);
	_emit8(0);
	_fn_usage_add();
	_emit16(i);
	_emit8(INSTR_HALT);
}

fn _parser_check_impl()
{
	let i, fail;
	fail = 0;
	for(i = 0; i < _parser.Functions.Count; ++i)
	{
		if(!_fn_addr_get(i))
		{
			let c, addr;
			addr = memory_r16(BANK_PARSER, _parser.Functions.Offset + 2 * i);
			stream_fputs_P(0, "Undefined reference to `");
			while(is_identifier_char(c = memory_r8(BANK_INPUT, addr++)))
			{
				stream_fputc(0, c);
			}

			stream_fputs(0, "`\n");
			fail = 1;
		}
	}

	if(fail) {
		error(ERROR_FN_UNDEFINED);
	}

	return 0;
}

fn _parser_fn()
{
	let i, used, parameters;

	tokenizer_next();
	EXPECT(TT_FN_IDENTIFIER, ERROR_EXPECTED_IDENTIFIER);

	if((i = identifier_map_find(&_parser.Functions, _token.Identifier)) < 0)
	{
		used = 0;
		i = _identifier_map_insert(&_parser.Functions, _token.Number);
	}
	else
	{
		used = 1;
		if(_fn_addr_get(i))
		{
			error(ERROR_FN_REDEFINITION);
		}
	}

	_fn_addr_set(i, _parser.Offset);

	parameters = 0;
	RETURN_IF(tokenizer_next());
	EXPECT('(', ERROR_EXPECTED_L_PAREN);
	RETURN_IF(tokenizer_next());
	while(_token.Type != ')')
	{
		EXPECT(TT_LET_IDENTIFIER, ERROR_EXPECTED_IDENTIFIER);
		RETURN_IF(identifier_map_insert(&_parser.Variables, _token.Number, _token.Identifier));
		++parameters;
		RETURN_IF(tokenizer_next());
		if(_token.Type == ',')
		{
			RETURN_IF(tokenizer_next());
			EXPECT(TT_LET_IDENTIFIER, ERROR_EXPECTED_IDENTIFIER);
		}
		else if(_token.Type != ')')
		{
			error(ERROR_UNEXPECTED_TOKEN);
		}
	}

	tokenizer_next();
	EXPECT('{', ERROR_EXPECTED_L_BRACE);
	if(used)
	{
		u16 j;
		if(parameters != _fn_params_get(i))
		{
			error(ERROR_FN_NUM_ARGS);
		}

		for(j = 0; j < _parser.UsagesCount; ++j)
		{
			u16 usage = _fn_usage_get(j);
			if(memory_r16(BANK_INTERPRETER, usage) == i)
			{
				memory_w16(BANK_INTERPRETER, usage, _fn_addr_get(i));
			}
		}
	}
	else
	{
		_fn_params_set(i, parameters);
	}

	_parser_fn_block(parameters);

	/* No return statement */
	if(memory_r8(BANK_INTERPRETER, OFFSET_CODE + _parser.Offset - 1) != INSTR_RET)
	{
		_emit8(INSTR_PUSHI8);
		_emit8(0);
		_emit8(INSTR_RET);
	}

	return 0;
}

fn _parser_statement()
{
	if eq(_token_type, TT_NULL) {
		error(ERROR_UNEXPECTED_EOF);
	}
	elif eq(_token_type, TT_FN_IDENTIFIER) {
		_parser_action();
	}
	elif eq(_token_type, TT_LET_IDENTIFIER) {
		_parser_assign();
	}
	elif eq(_token_type, TT_IF) {
		_parser_if();
	}
	elif eq(_token_type, TT_WHILE) {
		_parser_while();
	}
	elif eq(_token_type, TT_FOR) {
		_parser_for();
	}
	elif eq(_token_type, TT_DO) {
		_parser_do_while();
	}
	elif eq(_token_type, TT_LOOP) {
		_parser_loop();
	}
	elif eq(_token_type, TT_BREAK) {
		_parser_break();
	}
	elif eq(_token_type, TT_CONTINUE) {
		_parser_continue();
	}
	elif eq(_token_type, TT_RETURN) {
		_parser_return();
	}
	elif eq(_token_type, '{') {
		_parser_block();
	}

	error(ERROR_UNEXPECTED_TOKEN);
}

fn _popv(i)
{
	if lt(i, _num_globals) {
		_emit8(INSTR_POPG);
		_emit8(i);
	}
	else {
		_emit8(INSTR_POPL);
		_emit8(sub(i, _num_globals));
	}
}

fn _pushv(i)
{
	if lt(i, _num_globals) {
		_emit8(INSTR_PUSHG);
		_emit8(i);
	}
	else {
		_emit8(INSTR_PUSHL);
		_emit8(sub(i, _num_globals));
	}
}

fn _parser_assign()
{
	let i;
	if((i = identifier_map_find(&_parser.Variables, _token.Identifier)) < 0)
	{
		error(ERROR_UNDEFINED_IDENTIFIER);
	}

	tokenizer_next();
	EXPECT('=', ERROR_EXPECTED_ASSIGN);
	tokenizer_next();
	_parser_expression();
	_popv(i);
	EXPECT(';', ERROR_EXPECTED_SEMICOLON);
	return 0;
}

fn _parser_action()
{
	_parser_fn_call();

	/* Ignored return value */
	_emit8(INSTR_POP);
	RETURN_IF(tokenizer_next());
	return 0;
}

fn _parser_fn_call()
{
	let i, addr, args, parameters, impl;

	impl = 1;
	args = 0;
	addr = 0;

	if((i = _builtin_find(_token.Identifier)) >= 0)
	{
		/* Builtin Function */
		addr = -i - 1;
		parameters = _builtin_num_parameters(i);
	}
	else if((i = identifier_map_find(&_parser.Functions, _token.Identifier)) >= 0)
	{
		/* Already defined function */
		parameters = _fn_params_get(i);
		if(!(addr = _fn_addr_get(i)))
		{
			/* Not implemented yet */
			impl = 0;
			addr = i;
		}
	}
	else
	{
		/* New function */
		i = _identifier_map_insert(&_parser.Functions, _token.Number);
		_fn_addr_set(i, 0);
		impl = 0;
		addr = i;
		parameters = -1;
	}

	tokenizer_next();
	EXPECT('(', ERROR_EXPECTED_L_PAREN);
	tokenizer_next();
	while(_token.Type != ')')
	{
		_parser_expression();
		++args;
		if(_token.Type == ',')
		{
			tokenizer_next();
			if(_token.Type == ')')
			{
				error(ERROR_UNEXPECTED_TOKEN);
			}
		}
		else if(_token.Type != ')')
		{
			error(ERROR_UNEXPECTED_TOKEN);
		}
	}

	/* Check number of arguments */
	if(parameters >= 0)
	{
		if(args != parameters)
		{
			error(ERROR_FN_NUM_ARGS);
		}
	}
	else
	{
		_fn_params_set(i, args);
	}

	/* Call function */
	_emit8(INSTR_CALL);
	_emit8(args);
	if(!impl)
	{
		_fn_usage_add();
	}

	_emit16(addr);
	return 0;
}

fn _parser_var()
{
	let count;
	count = 0;
	do {
		tokenizer_next();
		EXPECT(TT_LET_IDENTIFIER, ERROR_EXPECTED_IDENTIFIER);
		identifier_map_insert(&_parser.Variables, _token.Number, _token.Identifier);
		++count;
		tokenizer_next();
	}
	while(_token_type == ',');
	EXPECT(';', ERROR_EXPECTED_SEMICOLON);
	return count;
}

fn _parser_fn_block(local_vars)
{
	tokenizer_next();
	while(_token_type == TT_LET)
	{
		local_vars += _parser_var();
		tokenizer_next();
	}

	if(local_vars)
	{
		_emit8(INSTR_DSP);
		_emit8(local_vars);
	}

	_parser_block_inner();
	_parser.Variables.Count -= local_vars;
	return 0;
}

fn _parser_block_inner()
{
	while(_token.Type != '}')
	{
		_parser_statement();
		tokenizer_next();
	}

	return 0;
}

fn _parser_block()
{
	EXPECT('{', ERROR_EXPECTED_L_BRACE);
	RETURN_IF(tokenizer_next());
	RETURN_IF(_parser_block_inner());
	return 0;
}

fn _parser_expression()
{
	if(_token.Type == TT_NUMBER)
	{
		_pushi(_token.Number);
		RETURN_IF(tokenizer_next());
	}
	else if(_token.Type == TT_LET_IDENTIFIER)
	{
		i16 i;
		if((i = identifier_map_find(&_parser.Variables, _token.Identifier)) < 0)
		{
			error(ERROR_UNDEFINED_IDENTIFIER);
		}

		_pushv(i);
		RETURN_IF(tokenizer_next());
	}
	else if(_token.Type == TT_FN_IDENTIFIER)
	{
		RETURN_IF(_parser_fn_call());
		RETURN_IF(tokenizer_next());
	}
	else
	{
		error(ERROR_UNEXPECTED_TOKEN);
	}

	return 0;
}

fn _parser_if()
{
	Tokenizer state;
	u16 idx_cond, idx_end;

	/* Parse condition */
	RETURN_IF(tokenizer_next());
	RETURN_IF(_parser_expression());

	/* Conditional jump to skip if */
	_emit8(INSTR_JZ);
	idx_cond = _parser.Offset;
	_skip(2);

	/* Parse if body */
	RETURN_IF(_parser_block());

	/* Save tokenizer state */
	state = _tokenizer;
	RETURN_IF(tokenizer_next());

	/* Is there an else or elif */
	if(_token.Type == TT_ELIF || _token.Type == TT_ELSE)
	{
		/* Jump to end of elif-else block */
		_emit8(INSTR_JMP);
		idx_end = _parser.Offset;
		_skip(2);

		/* Jump to else/elif block if false */
		memory_w16(BANK_INTERPRETER, OFFSET_CODE + idx_cond, _parser.Offset);

		if(_token.Type == TT_ELIF)
		{
			RETURN_IF(_parser_if());
		}
		else
		{
			RETURN_IF(tokenizer_next());
			RETURN_IF(_parser_block());
		}

		memory_w16(BANK_INTERPRETER, OFFSET_CODE + idx_end, _parser.Offset);
	}
	else
	{
		/* Reset state */
		_tokenizer = state;
		memory_w16(BANK_INTERPRETER, OFFSET_CODE + idx_cond, _parser.Offset);
	}

	return 0;
}

fn _parser_while()
{
	u16 idx_before, idx_branch;
	u8 prev_break, prev_continue;

	idx_before = _parser.Offset;

	/* Parse condition */
	RETURN_IF(tokenizer_next());
	RETURN_IF(_parser_expression());

	/* Conditional jump to exit loop */
	_emit8(INSTR_JZ);
	idx_branch = _parser.Offset;
	_skip(2);

	/* Loop body */
	prev_break = _parser.BreakStack.Top;
	prev_continue = _parser.ContinueStack.Top;

	++_parser.BreakNesting;
	++_parser.ContinueNesting;
	RETURN_IF(_parser_block());
	--_parser.BreakNesting;
	--_parser.ContinueNesting;

	/* Jump back to loop condition */
	_emit8(INSTR_JMP);
	_emit16(idx_before);

	/* Fill in exit address */
	memory_w16(BANK_INTERPRETER, OFFSET_CODE + idx_branch, _parser.Offset);

	/* Handle break and continue statements */
	address_stack_update(&_parser.BreakStack, prev_break, _parser.Offset);
	address_stack_update(&_parser.ContinueStack, prev_continue, idx_before);
	return 0;
}

fn _parser_loop()
{
	u16 idx_before;
	u8 prev_break, prev_continue;

	idx_before = _parser.Offset;

	/* Loop body */
	prev_break = _parser.BreakStack.Top;
	prev_continue = _parser.ContinueStack.Top;

	++_parser.BreakNesting;
	++_parser.ContinueNesting;
	RETURN_IF(tokenizer_next());
	RETURN_IF(_parser_block());
	--_parser.BreakNesting;
	--_parser.ContinueNesting;

	/* Jump back to loop condition */
	_emit8(INSTR_JMP);
	_emit16(idx_before);

	/* Handle break and continue statements */
	address_stack_update(&_parser.BreakStack, prev_break, _parser.Offset);
	address_stack_update(&_parser.ContinueStack, prev_continue, idx_before);
	return 0;
}

fn _parser_for()
{
	i16 i;
	u16 idx_cmp, idx_before, idx_branch;
	u8 prev_break, prev_continue, type;
	u32 chg;

	/* Parse condition */
	RETURN_IF(tokenizer_next());

	if((i = identifier_map_find(&_parser.Variables, _token.Identifier)) < 0)
	{
		error(ERROR_UNDEFINED_IDENTIFIER);
	}

	RETURN_IF(tokenizer_next());
	EXPECT('=', ERROR_EXPECTED_ASSIGN);
	RETURN_IF(tokenizer_next());
	RETURN_IF(_parser_expression());
	_popv(i);
	EXPECT(TT_TO, ERROR_UNEXPECTED_TOKEN);
	RETURN_IF(tokenizer_next());

	idx_before = _parser.Offset;
	_pushv(i);
	RETURN_IF(_parser_expression());
	_emit8(INSTR_CALL);
	_emit8(2);
	idx_cmp = _parser.Offset;
	_skip(2);

	chg = 1;
	type = TT_INC;
	if(_token.Type == TT_INC || _token.Type == TT_DEC)
	{
		type = _token.Type;
		RETURN_IF(tokenizer_next());
		EXPECT(TT_NUMBER, ERROR_EXPECTED_CONSTANT);
		chg = _token.Number;
		RETURN_IF(tokenizer_next());
	}

	/* Conditional jump to exit loop */
	_emit8(INSTR_JZ);
	idx_branch = _parser.Offset;
	_skip(2);

	/* Loop body */
	prev_break = _parser.BreakStack.Top;
	prev_continue = _parser.ContinueStack.Top;

	++_parser.BreakNesting;
	++_parser.ContinueNesting;
	RETURN_IF(_parser_block());
	--_parser.BreakNesting;
	--_parser.ContinueNesting;

	/* Increment */
	_pushv(i);
	_pushi(chg);
	_emit8(INSTR_CALL);
	_emit8(2);
	_emit16(type == TT_INC ? -1 : -2); /* add / sub */
	_popv(i);

	memory_w16(BANK_INTERPRETER, OFFSET_CODE + idx_cmp, type == TT_INC ? -18 : -19); /* le / ge */

	/* Jump back to loop condition */
	_emit8(INSTR_JMP);
	_emit16(idx_before);

	/* Fill in exit address */
	memory_w16(BANK_INTERPRETER, OFFSET_CODE + idx_branch, _parser.Offset);

	/* Handle break and continue statements */
	address_stack_update(&_parser.BreakStack, prev_break, _parser.Offset);
	address_stack_update(&_parser.ContinueStack, prev_continue, idx_before);
	return 0;
}

fn _parser_switch()
{
	u8 i, count, prev_break;
	u16 idx_skip, jt[64];

	RETURN_IF(tokenizer_next());
	RETURN_IF(_parser_expression());

	/* jump to jump table */
	_emit8(INSTR_JMP);
	idx_skip = _parser.Offset;
	_skip(2);
	EXPECT('[', ERROR_EXPECTED_L_BRACKET);

	prev_break = _parser.BreakStack.Top;

	count = 0;
	++_parser.BreakNesting;
	do
	{
		jt[count++] = _parser.Offset;
		RETURN_IF(tokenizer_next());
		EXPECT('{', ERROR_EXPECTED_L_BRACE);
		RETURN_IF(_parser_block());
		RETURN_IF(tokenizer_next());
		if(_token.Type == ',')
		{
			/* break */
			_emit8(INSTR_JMP);
			address_stack_push(&_parser.BreakStack, _parser.Offset);
			_skip(2);
		}
		else if(_token.Type == '=')
		{
			/* fallthrough */
			RETURN_IF(tokenizer_next());
			EXPECT('>', ERROR_UNEXPECTED_TOKEN);
		}
	} while(_token.Type != ']');
	--_parser.BreakNesting;

	/* jump over jump table */
	_emit8(INSTR_JMP);
	address_stack_push(&_parser.BreakStack, _parser.Offset);
	_skip(2);

	/* generate jump table */
	memory_w16(BANK_INTERPRETER, OFFSET_CODE + idx_skip, _parser.Offset);
	_emit8(INSTR_JT);
	_emit8(count);
	for(i = 0; i < count; ++i)
	{
		_emit16(jt[i]);
	}

	/* handle break */
	address_stack_update(&_parser.BreakStack, prev_break, _parser.Offset);
	return 0;
}

fn _parser_do_while()
{
	u16 idx_begin, idx_branch;
	u8 prev_break, prev_continue;

	idx_begin = _parser.Offset;

	/* Loop body */
	RETURN_IF(tokenizer_next());
	prev_break = _parser.BreakStack.Top;
	prev_continue = _parser.ContinueStack.Top;

	++_parser.BreakNesting;
	++_parser.ContinueNesting;
	RETURN_IF(_parser_block());
	--_parser.BreakNesting;
	--_parser.ContinueNesting;

	/* Parse condition */
	RETURN_IF(tokenizer_next());
	EXPECT(TT_WHILE, ERROR_EXPECTED_WHILE);
	RETURN_IF(tokenizer_next());
	RETURN_IF(_parser_expression());
	EXPECT(';', ERROR_EXPECTED_SEMICOLON);

	/* Conditional jump to loop beginning */
	idx_branch = _parser.Offset;
	_emit8(INSTR_JNZ);
	_emit16(idx_begin);

	/* Handle break and continue statements */
	address_stack_update(&_parser.BreakStack, prev_break, _parser.Offset);
	address_stack_update(&_parser.ContinueStack, prev_continue, idx_branch);
	return 0;
}

fn _parser_break()
{
	RETURN_IF(tokenizer_next());
	EXPECT(';', ERROR_EXPECTED_SEMICOLON);
	if(!_parser.BreakNesting)
	{
		error(ERROR_INV_BREAK);
	}

	_emit8(INSTR_JMP);
	address_stack_push(&_parser.BreakStack, _parser.Offset);
	_skip(2);
	return 0;
}

fn _parser_continue()
{
	RETURN_IF(tokenizer_next());
	EXPECT(';', ERROR_EXPECTED_SEMICOLON);
	if(!_parser.ContinueNesting)
	{
		error(ERROR_INV_CONTINUE);
	}

	_emit8(INSTR_JMP);
	address_stack_push(&_parser.ContinueStack, _parser.Offset);
	_skip(2);
	return 0;
}

fn _parser_return()
{
	RETURN_IF(tokenizer_next());
	if(_token.Type == ';')
	{
		_emit8(INSTR_PUSHI8);
		_emit8(0);
	}
	else
	{
		RETURN_IF(_parser_expression());
		EXPECT(';', ERROR_EXPECTED_SEMICOLON);
	}

	_emit8(INSTR_RET);
	return 0;
}











fn error(code) {
	exit 1;
}

fn main() {
	_keywords =
		"if\0"
		"elif\0"
		"else\0"
		"do\0"
		"while\0"
		"for\0"
		"to\0"
		"inc\0"
		"dec\0"
		"let\0"
		"fn\0"
		"break\0"
		"continue\0"
		"return\0"
		"loop\0"
		"true\0"
		"false\0"
		"exit\0"
		"|";
}
